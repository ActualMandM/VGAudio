//------------------------------------------------
//--- 010 Editor v8.0 Binary Template
//
//      File: adx.bt
//   Authors: Alex Barney
//   Version: 1.0
//   Purpose: Parse ADX audio files
//  Category: Audio
// File Mask: *.adx
//  ID Bytes: 80 00
//   History: 
//   1.0   Initial Release
//------------------------------------------------

struct History
{
    int16 hist1;
    int16 hist2;
};

struct Loop
{
    int16 LoopNum;
    int16 IsLooping;
    int32 LoopStartSample;
    int32 LoopStartByte;
    int32 LoopEndSample;
    int32 LoopEndByte;
};

struct Ainf
{
    char Magic[4];
    int32 size;
    char id[16];
    int16 Padding;
    int16 Volume;
    int16 PanningLeft;
    int16 PanningRight;
};

struct Cinf
{
    char Magic[4];
    //More unknown stuff
};

struct Header
{
    local int i;
    int16 Magic <format=hex>;
    int16 CopyrightOffset;
    byte EncodingType;
    byte BlockSize;
    byte BitDepth;
    byte ChannelCount;
    int32 SampleRate;
    int32 SampleCount;
    int16 HighpassFreq;
    byte Version;
    byte Flags;

    if(Version == 4) 
    {
        int32 Padding;
        for(i = 0; i < (int)Max(2, ChannelCount); i++)
        {
            History history;
        }
    }

    if(FTell() + 24 > CopyrightOffset)
        break;

    int16 AlignmentSamples;
    int16 LoopCount;
    for(i = 0; i < LoopCount; i++)
    {
        Loop loop;
    }
};

struct FrameChannel(int blockSize)
{
    int16 FilterNum : 3;
    int16 Scale : 13;
    byte Samples[blockSize - 2];
};

struct Frame(int blockSize, int channelCount)
{
    local int i;
    for(i = 0; i < channelCount; i++)
    {
        FrameChannel Channels(blockSize);
    }
};

struct Footer
{
    int16 Magic <format=hex>;
    int16 PaddingCount;
    byte Padding[PaddingCount];
};

struct Data (Header &head)
{
    char CopyrightMarker[6];
    while (!FEof() && ReadUShort() != 0x8001)
    {
        Frame Frames(head.BlockSize, head.ChannelCount);
    }    
};

BigEndian();
Header head;

FSeek(head.CopyrightOffset - 2);
Data data(head);
Footer footer;
